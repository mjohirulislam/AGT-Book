{"version":"1","records":[{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow"},"content":"Welcome to Algorithmic Game Theory! In this book, we explore what happens when computer science meets economics. We aren’t just looking at algorithms that run on a single computer; we are looking at systems where the “inputs” are people (or agents) who are trying to maximize their own benefit.","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Core Concept: The Price of Anarchy"},"type":"lvl3","url":"/#the-core-concept-the-price-of-anarchy","position":2},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Core Concept: The Price of Anarchy"},"content":"One of the biggest surprises in this field is that selfish behavior can hurt everyone, including the people being selfish. We often assume that giving people more options (like building a new road) will always improve the situation. Game Theory shows us this isn’t true.\n\nThis phenomenon is captured by Braess’s Paradox.","type":"content","url":"/#the-core-concept-the-price-of-anarchy","position":3},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"The Scenario","lvl3":"The Core Concept: The Price of Anarchy"},"type":"lvl4","url":"/#the-scenario","position":4},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"The Scenario","lvl3":"The Core Concept: The Price of Anarchy"},"content":"Imagine 4,000 drivers want to get from a Start point to an End point.\n\nThere are two initial routes: Top and Bottom.\n\nEach route has two parts: a wide highway (fast, always takes 45 mins) and a narrow road (slow, takes longer if there is traffic).\n\nThe Paradox: If we build a super-fast “teleport” road connecting the middle points, everyone will try to use it to save time. But because everyone does this, the traffic jams get so bad that every single driver arrives later than before.\n\nThis proves that individual rationality (doing what is best for you) can lead to collective irrationality (a result that is bad for everyone).\n\nimport networkx as nx\nimport matplotlib.pyplot as plt\n\ndef draw_braess_network():\n    # 1. Create a directed graph\n    G = nx.DiGraph()\n    \n    # 2. Add Nodes\n    # Positions: Start (Left), End (Right), A (Top), B (Bottom)\n    pos = {\n        'Start': (0, 1),\n        'End': (2, 1),\n        'A': (1, 2),\n        'B': (1, 0)\n    }\n    \n    # 3. Add Edges (Roads) with labels for their Cost (Travel Time)\n    # T = number of cars\n    edges = [\n        ('Start', 'A', 'Narrow\\n(T / 100)'),\n        ('Start', 'B', 'Wide\\n(45 mins)'),\n        ('A', 'End', 'Wide\\n(45 mins)'),\n        ('B', 'End', 'Narrow\\n(T / 100)'),\n        # The Shortcut\n        ('A', 'B', 'Shortcut\\n(0 mins)')\n    ]\n    \n    G.add_edges_from([(u, v) for u, v, label in edges])\n    \n    # 4. Draw the Graph\n    plt.figure(figsize=(10, 6))\n    \n    # Draw Nodes\n    nx.draw_networkx_nodes(G, pos, node_size=2000, node_color='lightblue', edgecolors='black')\n    nx.draw_networkx_labels(G, pos, font_size=12, font_weight='bold')\n    \n    # Draw Edges\n    nx.draw_networkx_edges(G, pos, arrowstyle='->', arrowsize=20, edge_color='gray', width=2)\n    \n    # Draw Edge Labels (The Costs)\n    edge_labels = {(u, v): label for u, v, label in edges}\n    nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_color='red', font_size=10)\n    \n    # Title and Layout\n    plt.title(\"The Braess's Paradox Network\", fontsize=15)\n    plt.axis('off') # Turn off the x/y axis numbers\n    plt.margins(0.2)\n    plt.show()\n\n# Run the function to display the graph\ndraw_braess_network()\n\n\n\nimport matplotlib.pyplot as plt\n\ndef calculate_travel_time(drivers, use_shortcut=False):\n    \"\"\"\n    Calculates total travel time for a single driver based on traffic distribution.\n    \n    Path options:\n    1. Start -> A -> End (Top Path)\n    2. Start -> B -> End (Bottom Path)\n    3. Start -> A -> B -> End (The Zig-Zag Shortcut)\n    \"\"\"\n    \n    # Cost functions\n    # Wide road: Always takes 45 minutes\n    # Narrow road: Takes (number_of_drivers / 100) minutes\n    \n    if not use_shortcut:\n        # NASH EQUILIBRIUM WITHOUT SHORTCUT\n        # Drivers split 50/50 because paths are identical.\n        drivers_top = drivers / 2\n        drivers_bottom = drivers / 2\n        \n        # Time = (Narrow Road) + (Wide Road)\n        time_top = (drivers_top / 100) + 45\n        time_bottom = 45 + (drivers_bottom / 100)\n        \n        return time_top\n    \n    else:\n        # NASH EQUILIBRIUM WITH SHORTCUT\n        # The shortcut (A->B) is instantaneous (0 mins).\n        # Everyone tries to take Start->A->B->End because A is better than the wide road \n        # and B is better than the wide road.\n        \n        # All 4000 drivers jam into the narrow roads.\n        time_zigzag = (drivers / 100) + 0 + (drivers / 100)\n        return time_zigzag\n\n# --- Parameters ---\ntotal_drivers = 4000\n\n# 1. Calculate Time WITHOUT the shortcut\ntime_before = calculate_travel_time(total_drivers, use_shortcut=False)\n\n# 2. Calculate Time WITH the shortcut\ntime_after = calculate_travel_time(total_drivers, use_shortcut=True)\n\n# --- Output Results ---\nprint(f\"--- Braess's Paradox Simulation ---\")\nprint(f\"Total Drivers: {total_drivers}\")\nprint(f\"\\nScenario 1: Two separate routes (No shortcut)\")\nprint(f\"Travel Time per Driver: {time_before} minutes\")\n\nprint(f\"\\nScenario 2: Ultra-fast shortcut added\")\nprint(f\"Travel Time per Driver: {time_after} minutes\")\n\nprint(f\"\\nResult: Adding the shortcut made everyone {time_after - time_before} minutes slower!\")\n\n# --- Visualization ---\nlabels = ['Before Shortcut', 'After Shortcut']\ntimes = [time_before, time_after]\n\nplt.figure(figsize=(8, 5))\nplt.bar(labels, times, color=['green', 'red'])\nplt.ylabel('Minutes to Commute')\nplt.title(\"Impact of 'Selfish Routing' on Travel Time\")\nplt.ylim(0, 90)\nfor i, v in enumerate(times):\n    plt.text(i, v + 2, str(v) + \" mins\", ha='center', fontweight='bold')\nplt.show()\n\n\n\n\n\n","type":"content","url":"/#the-scenario","position":5},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"What just happened?","lvl3":"The Core Concept: The Price of Anarchy"},"type":"lvl4","url":"/#what-just-happened","position":6},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"What just happened?","lvl3":"The Core Concept: The Price of Anarchy"},"content":"In the code above, you will see that adding a shortcut (Scenario 2) actually increased travel time from 65 minutes to 80 minutes.\n\nBefore: Drivers split up. Traffic was balanced.\n\nAfter: The “Narrow” roads became so attractive individually that everyone used them, causing a massive bottleneck.\n\nThis teaches us that simply “adding capacity” (like building more roads or buying more servers) doesn’t always solve congestion if you ignore game theory!\n\n","type":"content","url":"/#what-just-happened","position":7},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl2":"Chapter 4: Algorithmic Mechanism Design - The Trilemma"},"type":"lvl2","url":"/#chapter-4-algorithmic-mechanism-design-the-trilemma","position":8},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl2":"Chapter 4: Algorithmic Mechanism Design - The Trilemma"},"content":"We have a new challenge. Suppose you are selling Cloud Storage on a server.\n\nTotal Capacity: 100 GB (W)\n\nBidders: n companies. Each wants a specific amount of space (w_i) and has a private value (v_i) for it.\n\nThis is the famous Knapsack Problem. We want to fit the most valuable combination of files into the limited space.","type":"content","url":"/#chapter-4-algorithmic-mechanism-design-the-trilemma","position":9},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Impossible Triangle (The Trilemma)","lvl2":"Chapter 4: Algorithmic Mechanism Design - The Trilemma"},"type":"lvl3","url":"/#the-impossible-triangle-the-trilemma","position":10},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Impossible Triangle (The Trilemma)","lvl2":"Chapter 4: Algorithmic Mechanism Design - The Trilemma"},"content":"We want an auction that is:\n\nDSIC (Truthful): People tell the truth about their value.\n\nOptimal: We get the absolute maximum total value possible.\n\nPolynomial Time (Fast): It runs quickly, even with thousands of bidders.\n\nBad News: We can’t have all three. The Knapsack Problem is NP-Hard. Solving it perfectly takes too long (exponential time).","type":"content","url":"/#the-impossible-triangle-the-trilemma","position":11},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Solution: Approximation","lvl2":"Chapter 4: Algorithmic Mechanism Design - The Trilemma"},"type":"lvl3","url":"/#the-solution-approximation","position":12},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Solution: Approximation","lvl2":"Chapter 4: Algorithmic Mechanism Design - The Trilemma"},"content":"Since we can’t be perfect and fast, we compromise. We design an algorithm that is fast and “pretty good” (Approximate).\n\nThe Greedy Heuristic:\nInstead of checking every combination, we look at the “Bang for the Buck” (Value per GB).\n\nCalculate density d_i = \\frac{v_i}{w_i} for everyone.\n\nSort bidders from highest density to lowest.\n\nLet them in one by one until the server is full.\n\nDoes this work? Let’s race the “Perfect” algorithm against the “Greedy” one.\n\nimport time\n\n# --- SETUP ---\n# Capacity of our Server (e.g., 50 GB)\nCAPACITY = 50\n\n# Bidders: (Name, Value $, Size GB)\n# Notice: 'C' has high value ($60) but is huge (50GB). \n# 'A' and 'B' are smaller but have good value density.\nbidders = [\n    {'name': 'A', 'value': 30, 'size': 10},\n    {'name': 'B', 'value': 20, 'size': 10},\n    {'name': 'C', 'value': 60, 'size': 50},  # Big, valuable item\n    {'name': 'D', 'value': 40, 'size': 20},\n    {'name': 'E', 'value': 15, 'size': 15},\n]\n\n# --- ALGORITHM 1: THE OPTIMAL (SLOW) WAY ---\n# This checks every possible subset (Recursive/DP)\ndef get_optimal_value(capacity, items, n):\n    if n == 0 or capacity == 0:\n        return 0\n    \n    # If item is too big, skip it\n    if items[n-1]['size'] > capacity:\n        return get_optimal_value(capacity, items, n-1)\n    \n    else:\n        # Return max of: \n        # (1) Including the item\n        # (2) Excluding the item\n        include = items[n-1]['value'] + get_optimal_value(capacity - items[n-1]['size'], items, n-1)\n        exclude = get_optimal_value(capacity, items, n-1)\n        return max(include, exclude)\n\n# --- ALGORITHM 2: THE GREEDY (FAST) WAY ---\n# Sorts by Value/Size ratio\ndef run_greedy_auction(capacity, items):\n    # 1. Calculate Density (Value / Size)\n    for item in items:\n        item['density'] = item['value'] / item['size']\n    \n    # 2. Sort by Density (High to Low)\n    sorted_items = sorted(items, key=lambda x: x['density'], reverse=True)\n    \n    current_weight = 0\n    total_value = 0\n    winners = []\n    \n    for item in sorted_items:\n        if current_weight + item['size'] <= capacity:\n            winners.append(item['name'])\n            current_weight += item['size']\n            total_value += item['value']\n            \n    return total_value, winners\n\n# --- RUN COMPARISON ---\n\nprint(\"--- Knapsack Auction Simulation ---\")\nprint(f\"Server Capacity: {CAPACITY} GB\")\n\n# Run Optimal\nstart_opt = time.time()\nopt_val = get_optimal_value(CAPACITY, bidders, len(bidders))\nend_opt = time.time()\nprint(f\"\\n[Optimal Algo]: Max Possible Value = ${opt_val} (Time: {end_opt - start_opt:.5f}s)\")\n\n# Run Greedy\nstart_greedy = time.time()\ngreedy_val, greedy_winners = run_greedy_auction(CAPACITY, bidders)\nend_greedy = time.time()\n\nprint(f\"\\n[Greedy Algo]: Value Found = ${greedy_val} (Time: {end_greedy - start_greedy:.5f}s)\")\nprint(f\"Winners: {greedy_winners}\")\nprint(f\"Performance: {(greedy_val/opt_val)*100:.1f}% of Optimal\")\n\n\n\n","type":"content","url":"/#the-solution-approximation","position":13},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"Analysis: The “Price” of Simplicity","lvl3":"The Solution: Approximation","lvl2":"Chapter 4: Algorithmic Mechanism Design - The Trilemma"},"type":"lvl4","url":"/#analysis-the-price-of-simplicity","position":14},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"Analysis: The “Price” of Simplicity","lvl3":"The Solution: Approximation","lvl2":"Chapter 4: Algorithmic Mechanism Design - The Trilemma"},"content":"In the simulation above, you might see that the Greedy Algorithm didn’t find the perfect $60 solution (Item C). Instead, it might have filled the knapsack with smaller items (A, B, D) for a total of $90. Wait... actually, in this specific case, Greedy often wins!\n\nBut consider a case where Greedy fails:\n\nItem A: Value 2, Size 1 (Density 2)\n\nItem B: Value 50, Size 50 (Density 1)\n\nCapacity: 50\n\nGreedy picks A (density 2). Now capacity is 49. Item B doesn’t fit. Total value: $2.\nOptimal picks B. Total value: $50.\n\nThe Fix:\nTo prevent catastrophic failures, our Greedy Mechanism has a final check:\n\nRun the Greedy sort.\n\nCompare that result against just picking the single most valuable item that fits.\n\n[cite_start]Return the better of the two[cite: 234].\n\n[cite_start]Theorem: This modified Greedy algorithm guarantees at least 50% of the optimal value[cite: 243].\n\nWhy do we care?\nBecause the Greedy algorithm is Monotone (getting a higher value or smaller size never hurts your chances). [cite_start]Because it is monotone, Myerson’s Lemma applies, and we can calculate payments that make this truthful[cite: 255]. We traded perfection for speed, but we kept truthfulness!\n\n","type":"content","url":"/#analysis-the-price-of-simplicity","position":15},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl2":"Chapter 5: Revenue Maximization - The Art of the Reserve Price"},"type":"lvl2","url":"/#chapter-5-revenue-maximization-the-art-of-the-reserve-price","position":16},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl2":"Chapter 5: Revenue Maximization - The Art of the Reserve Price"},"content":"Until now, we have been “benevolent” designers. We wanted the item to go to the highest bidder (v_i) to maximize societal happiness.\n\nBut what if you are a seller (like Google or a government selling spectrum)? You care about Revenue.","type":"content","url":"/#chapter-5-revenue-maximization-the-art-of-the-reserve-price","position":17},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Conflict: Welfare vs. Revenue","lvl2":"Chapter 5: Revenue Maximization - The Art of the Reserve Price"},"type":"lvl3","url":"/#the-conflict-welfare-vs-revenue","position":18},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Conflict: Welfare vs. Revenue","lvl2":"Chapter 5: Revenue Maximization - The Art of the Reserve Price"},"content":"Imagine a single bidder, Alice, with a valuation v \\sim U[0, 100] (Uniformly distributed).\n\nWelfare Maximizer: We just give it to her (price $0). She is happy (v), we get $0. Total Welfare = v.\n\nRevenue Maximizer: We set a price tag (Take-it-or-leave-it).\n\nIf we set price $10: She buys often, but we make little.\n\nIf we set price $90: We make a lot per sale, but she rarely buys.\n\nThis is the classic Monopoly Pricing Problem.","type":"content","url":"/#the-conflict-welfare-vs-revenue","position":19},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Solution: Myerson’s Optimal Auction","lvl2":"Chapter 5: Revenue Maximization - The Art of the Reserve Price"},"type":"lvl3","url":"/#the-solution-myersons-optimal-auction","position":20},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Solution: Myerson’s Optimal Auction","lvl2":"Chapter 5: Revenue Maximization - The Art of the Reserve Price"},"content":"Roger Myerson (yes, him again) proved that to maximize revenue, we shouldn’t look at the bids directly. We should look at the Virtual Valuations (\\phi).\n\nThe “Virtual Valuation” is a formula that adjusts a bid based on the probability distribution of the bidder’s value.\\phi(v_i) = v_i - \\frac{1 - F(v_i)}{f(v_i)}\n\nv_i: The bid.\n\nF(v_i): The probability someone has a value less than this (CDF).\n\nf(v_i): The probability density (PDF).\n\nThe Optimal Auction Rule:\n\nCalculate \\phi(v_i) for everyone.\n\nWinner is the person with the highest Virtual Valuation (provided \\phi > 0).\n\nThe point where \\phi(v) = 0 acts as the Optimal Reserve Price.\n\nLet’s simulate this for a Uniform Distribution (where the math is easy).\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef run_revenue_simulation(num_auctions=10000):\n    \"\"\"\n    Compares Standard Second-Price Auction vs. Optimal Auction (with Reserve)\n    Scenario: 2 Bidders, Valuations drawn from Uniform [0, 100]\n    \"\"\"\n    \n    # 1. Setup\n    # Uniform Distribution U[0, 100]\n    # For U[0,100], the Virtual Valuation is phi(v) = 2v - 100.\n    # We want phi(v) >= 0, so 2v >= 100 --> v >= 50.\n    # Therefore, the Optimal Reserve Price is $50.\n    RESERVE_PRICE = 50 \n    \n    revenue_standard = []\n    revenue_optimal = []\n    \n    for _ in range(num_auctions):\n        # Generate random values for Bidder A and Bidder B\n        bids = np.random.uniform(0, 100, 2)\n        bids.sort() # Sort so bids[0] is low, bids[1] is high\n        \n        low_bid = bids[0]\n        high_bid = bids[1]\n        \n        # --- MECHANISM A: STANDARD VICKREY (Second Price) ---\n        # Highest bidder wins, pays second highest price.\n        # Reserve is effectively $0.\n        revenue_standard.append(low_bid)\n        \n        # --- MECHANISM B: MYERSON OPTIMAL (Reserve Price $50) ---\n        # Rule: Both must bid at least $50.\n        \n        # Case 1: Both fail reserve (Both < 50) -> No Sale\n        if high_bid < RESERVE_PRICE:\n            revenue_optimal.append(0)\n            \n        # Case 2: Only one clears reserve (High > 50, Low < 50) -> Pay Reserve\n        elif high_bid >= RESERVE_PRICE and low_bid < RESERVE_PRICE:\n            revenue_optimal.append(RESERVE_PRICE)\n            \n        # Case 3: Both clear reserve -> Pay Second Highest (Standard)\n        else: # Both >= 50\n            revenue_optimal.append(low_bid)\n            \n    return revenue_standard, revenue_optimal\n\n# Run Simulation\nrev_std, rev_opt = run_revenue_simulation()\n\n# --- ANALYSIS ---\navg_std = np.mean(rev_std)\navg_opt = np.mean(rev_opt)\nlift = ((avg_opt - avg_std) / avg_std) * 100\n\nprint(f\"--- Revenue Comparison (2 Bidders, U[0,100]) ---\")\nprint(f\"Average Revenue (Standard 2nd Price): ${avg_std:.2f}\")\nprint(f\"Average Revenue (Optimal /w Reserve): ${avg_opt:.2f}\")\nprint(f\"Revenue Increase: +{lift:.1f}%\")\n\n# --- VISUALIZATION ---\nplt.figure(figsize=(10,5))\nplt.hist(rev_std, bins=50, alpha=0.5, label='Standard Revenue', color='blue')\nplt.hist(rev_opt, bins=50, alpha=0.5, label='Optimal Revenue', color='green')\nplt.axvline(avg_std, color='blue', linestyle='dashed', linewidth=2)\nplt.axvline(avg_opt, color='green', linestyle='dashed', linewidth=2)\nplt.title(f\"Impact of Reserve Price ($50) on Seller Revenue\")\nplt.xlabel(\"Revenue per Auction ($)\")\nplt.ylabel(\"Frequency\")\nplt.legend()\nplt.show()\n\n\n\n","type":"content","url":"/#the-solution-myersons-optimal-auction","position":21},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"What just happened?","lvl3":"The Solution: Myerson’s Optimal Auction","lvl2":"Chapter 5: Revenue Maximization - The Art of the Reserve Price"},"type":"lvl4","url":"/#what-just-happened-1","position":22},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"What just happened?","lvl3":"The Solution: Myerson’s Optimal Auction","lvl2":"Chapter 5: Revenue Maximization - The Art of the Reserve Price"},"content":"You should see that the Optimal Auction generated significantly more revenue (usually around 10-15% more in this specific setting).\n\nHow did it do that?\nLook at the histogram or the logic in the code:\n\nThe “Standard” Auction often sells for very low prices (e.g., if bids are $5 and $2, revenue is $2).\n\nThe “Optimal” Auction refuses to sell for less than $50.\n\nIf the high bidder was $80 and the low bidder was $2, the price jumps from $2 to $50 (the reserve).\n\nTrade-off: Sometimes nobody buys (if both are < $50), so we get $0.\n\nConclusion:\nBy risking a “no-sale,” the seller forces high-value bidders to pay a premium. This demonstrates that Market Efficiency (Social Welfare) and Profit (Revenue) are often at odds. To make the most money, you sometimes have to refuse to sell to people who want the item!\n\n","type":"content","url":"/#what-just-happened-1","position":23},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl2":"Chapter 6: Simple vs. Optimal - The Power of Competition"},"type":"lvl2","url":"/#chapter-6-simple-vs-optimal-the-power-of-competition","position":24},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl2":"Chapter 6: Simple vs. Optimal - The Power of Competition"},"content":"We established that the Optimal Auction (using virtual valuations and specific reserve prices) beats the Standard Second-Price auction.\n\nHowever, the Optimal Auction is complex. You need detailed market data to calculate the perfect reserve price. If you get it wrong, you lose money.","type":"content","url":"/#chapter-6-simple-vs-optimal-the-power-of-competition","position":25},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Bulow-Klemperer Theorem","lvl2":"Chapter 6: Simple vs. Optimal - The Power of Competition"},"type":"lvl3","url":"/#the-bulow-klemperer-theorem","position":26},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"The Bulow-Klemperer Theorem","lvl2":"Chapter 6: Simple vs. Optimal - The Power of Competition"},"content":"In 1996, economists Bulow and Klemperer proved a shocking result that changed auction theory. They compared two scenarios:\n\nThe Genius: You keep N bidders and run the mathematically Optimal Auction (perfect reserve price).\n\nThe Hustler: You run a simple Second-Price Auction (no reserve price), but you go out and find one extra bidder (N+1).\n\nThe Theorem:\n\nThe Simple Auction with N+1 bidders earns MORE revenue than the Optimal Auction with N bidders.\n\nThis teaches us a profound business lesson: It is better to invest in marketing (finding more customers) than in market research (optimizing prices). Competition is more powerful than complex math.","type":"content","url":"/#the-bulow-klemperer-theorem","position":27},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"Strategy 2: The Single Sample","lvl2":"Chapter 6: Simple vs. Optimal - The Power of Competition"},"type":"lvl3","url":"/#strategy-2-the-single-sample","position":28},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl3":"Strategy 2: The Single Sample","lvl2":"Chapter 6: Simple vs. Optimal - The Power of Competition"},"content":"What if you can’t find more bidders? How do you set a reserve price without knowing the market distribution?\nA simple trick is the Single Sample method:\n\nTake the first bidder’s bid.\n\nKick them out (sorry!).\n\nUse their bid as the Reserve Price for everyone else.\n\nIt sounds wasteful to kick someone out, but this method is proven to get a very good approximation of the optimal revenue.\n\nLet’s prove the Bulow-Klemperer Theorem with code.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef compare_auctions(num_simulations=10000):\n    \"\"\"\n    Proves Bulow-Klemperer: \n    Simple Auction (N+1 Bidders) > Optimal Auction (N Bidders)\n    \"\"\"\n    \n    # PARAMETERS\n    N = 5  # Number of bidders in the \"Base\" case\n    # Valuation Distribution: Uniform [0, 100]\n    # For U[0,100], the Optimal Reserve Price is mathematically calculated as $50.\n    OPTIMAL_RESERVE = 50 \n    \n    rev_optimal_n = []\n    rev_simple_n_plus_1 = []\n    \n    for _ in range(num_simulations):\n        # --- SCENARIO 1: OPTIMAL AUCTION (N Bidders) ---\n        # We have N bidders. We use the Perfect Reserve Price ($50).\n        bids_n = np.random.uniform(0, 100, N)\n        bids_n.sort() # Sort low to high\n        \n        # Logic:\n        # 1. If highest bid < Reserve -> Revenue 0\n        # 2. If highest > Reserve but 2nd highest < Reserve -> Revenue = Reserve\n        # 3. If 2nd highest > Reserve -> Revenue = 2nd Highest\n        \n        highest = bids_n[-1]\n        second = bids_n[-2]\n        \n        if highest < OPTIMAL_RESERVE:\n            rev_optimal_n.append(0)\n        elif second < OPTIMAL_RESERVE:\n            rev_optimal_n.append(OPTIMAL_RESERVE)\n        else:\n            rev_optimal_n.append(second)\n            \n        # --- SCENARIO 2: SIMPLE AUCTION (N+1 Bidders) ---\n        # We add 1 extra bidder. We use NO Reserve Price (Standard Vickrey).\n        bids_plus = np.random.uniform(0, 100, N + 1)\n        bids_plus.sort()\n        \n        # Revenue is simply the second highest bid\n        rev_simple_n_plus_1.append(bids_plus[-2])\n        \n    return rev_optimal_n, rev_simple_n_plus_1\n\n# --- RUN SIMULATION ---\nrev_opt, rev_simp = compare_auctions()\n\navg_opt = np.mean(rev_opt)\navg_simp = np.mean(rev_simp)\n\nprint(f\"--- The Bulow-Klemperer Theorem ---\")\nprint(f\"Scenario 1: Optimal Auction (Complex) with N Bidders\")\nprint(f\"Average Revenue: ${avg_opt:.2f}\")\nprint(f\"\\nScenario 2: Simple Auction (Vickrey) with N+1 Bidders\")\nprint(f\"Average Revenue: ${avg_simp:.2f}\")\n\ndiff = avg_simp - avg_opt\nprint(f\"\\nResult: Simply adding 1 bidder beat the optimal math by ${diff:.2f} per auction!\")\n\n# --- VISUALIZATION ---\nplt.figure(figsize=(10, 6))\nplt.hist(rev_opt, bins=30, alpha=0.5, label=f'Optimal (N Bidders)', color='red')\nplt.hist(rev_simp, bins=30, alpha=0.5, label=f'Simple (N+1 Bidders)', color='blue')\nplt.axvline(avg_opt, color='red', linestyle='--', linewidth=2)\nplt.axvline(avg_simp, color='blue', linestyle='--', linewidth=2)\nplt.title(\"Revenue: Complex Math vs. One Extra Bidder\")\nplt.xlabel(\"Revenue ($)\")\nplt.legend()\nplt.show()\n\n\n\n\n\n","type":"content","url":"/#strategy-2-the-single-sample","position":29},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"Analysis","lvl3":"Strategy 2: The Single Sample","lvl2":"Chapter 6: Simple vs. Optimal - The Power of Competition"},"type":"lvl4","url":"/#analysis","position":30},{"hierarchy":{"lvl1":"Chapter 1: Introduction - When Selfish is Slow","lvl4":"Analysis","lvl3":"Strategy 2: The Single Sample","lvl2":"Chapter 6: Simple vs. Optimal - The Power of Competition"},"content":"The simulation confirms the Bulow-Klemperer Theorem.\n\nEven though Scenario 1 used the perfect mathematical reserve price (derived from Myerson’s Lemma), it couldn’t beat Scenario 2, which used no math at all but had just one extra participant.\n\nKey Takeaways for Mechanism Design:\n\nMarket Thickness matters more than Market Design. If you can get more people to show up, you don’t need complex rules.\n\nRobustness. The Simple Auction works for any distribution. The Optimal Auction fails if you guessed the distribution wrong (e.g., if you thought the reserve should be $50 but the market changed and it should be $30).\n\nSimplicity. Simple auctions (like eBay’s) are often preferred not just because they are easy to code, but because they are “Prior-Independent.” They work well without knowing secret information about the bidders.","type":"content","url":"/#analysis","position":31},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish"},"type":"lvl1","url":"/chapter2","position":0},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish"},"content":"In Chapter 1, we saw how selfish behavior causes traffic jams. In this chapter, we ask the reverse question: Can we design a system where selfish behavior actually leads to the best possible outcome?\n\nThis field is called Mechanism Design (often called “Reverse Game Theory”). Instead of analyzing a game, we build the game rules so that players, acting in their own self-interest, unintentionally solve a problem for us.","type":"content","url":"/chapter2","position":1},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish","lvl2":"The Problem: Selling a Single Item"},"type":"lvl2","url":"/chapter2#the-problem-selling-a-single-item","position":2},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish","lvl2":"The Problem: Selling a Single Item"},"content":"Imagine you are selling a slightly used smartphone. You have n potential buyers.\n\nEach buyer has a private valuation (v_i): the maximum amount they are willing to pay. You don’t know this number.\n\nYou want to give the phone to the person who values it the most (this is called Maximizing Social Surplus).\n\nHow do you get them to tell you their true value? If you just ask “How much will you pay?”, they might lie to get a better deal.","type":"content","url":"/chapter2#the-problem-selling-a-single-item","position":3},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish","lvl2":"Attempt 1: The First-Price Auction"},"type":"lvl2","url":"/chapter2#attempt-1-the-first-price-auction","position":4},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish","lvl2":"Attempt 1: The First-Price Auction"},"content":"This is the most intuitive format.\n\nEveryone writes a bid in a sealed envelope.\n\nHighest bid wins.\n\nWinner pays their bid.\n\nThe Flaw: If you value the phone at $100, you would never bid $100. If you did, your profit (utility) would be $0. You are incentivized to shade your bid (e.g., bid $80 to try and make $20 profit).\n\nThis makes the game complex. Everyone is guessing what everyone else is guessing.","type":"content","url":"/chapter2#attempt-1-the-first-price-auction","position":5},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish","lvl2":"Attempt 2: The Vickrey Auction (Second-Price)"},"type":"lvl2","url":"/chapter2#attempt-2-the-vickrey-auction-second-price","position":6},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish","lvl2":"Attempt 2: The Vickrey Auction (Second-Price)"},"content":"This is the “magic” solution used in modern economics (and variations of it are used by eBay and Google Ads).\n\nEveryone writes a bid in a sealed envelope.\n\nHighest bid wins.\n\nWinner pays the Second-Highest price.\n\nThe Claim: In a Second-Price auction, your best strategy is to tell the exact truth, no matter what anyone else does.\n\nLet’s prove this with a simulation.\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\ndef run_auction(bidders, valuations, bids, auction_type='second_price'):\n    \"\"\"\n    Simulates a single-item auction.\n    bidders: List of names\n    valuations: List of true values (v_i)\n    bids: List of actual bids submitted (b_i)\n    auction_type: 'first_price' or 'second_price'\n    \"\"\"\n    \n    # 1. Find the Winner (Highest Bid)\n    # We use np.argmax to find the index of the highest bid\n    winner_idx = np.argmax(bids)\n    winner_name = bidders[winner_idx]\n    winning_bid = bids[winner_idx]\n    \n    # 2. Determine Payment\n    if auction_type == 'first_price':\n        payment = winning_bid\n    elif auction_type == 'second_price':\n        # Sort bids to find the second highest\n        sorted_bids = sorted(bids, reverse=True)\n        # The second highest is at index 1\n        payment = sorted_bids[1]\n        \n    # 3. Calculate Utility (Profit)\n    # Utility = True Value - Payment (if you win)\n    # Utility = 0 (if you lose)\n    winner_true_value = valuations[winner_idx]\n    utility = winner_true_value - payment\n    \n    return winner_name, payment, utility\n\n# --- SIMULATION ---\n\n# Define 5 Bidders and their TRUE valuations (unknown to the seller)\nnames = ['Alice', 'Bob', 'Charlie', 'Dave', 'Eve']\ntrue_values = [100, 80, 60, 90, 40]  # Alice wants it most ($100)\n\nprint(f\"--- TRUE VALUATIONS (Private) ---\")\nfor n, v in zip(names, true_values):\n    print(f\"{n}: ${v}\")\nprint(\"-\" * 30)\n\n# SCENARIO 1: First-Price Auction (Strategic Bidding)\n# Everyone lies! They bid 80% of their value to try and make a profit.\nbids_first_price = [v * 0.8 for v in true_values] \n\nwinner_1, pay_1, util_1 = run_auction(names, true_values, bids_first_price, 'first_price')\n\nprint(f\"\\n[Scenario 1: First-Price Auction]\")\nprint(f\"Bids (Strategic): {bids_first_price}\")\nprint(f\"Winner: {winner_1}\")\nprint(f\"Payment: ${pay_1:.2f}\")\nprint(f\"Winner's Profit (Utility): ${util_1:.2f}\")\n\n# SCENARIO 2: Vickrey (Second-Price) Auction (Truthful Bidding)\n# Everyone tells the truth because the math says they should.\nbids_second_price = true_values # Direct truth\n\nwinner_2, pay_2, util_2 = run_auction(names, true_values, bids_second_price, 'second_price')\n\nprint(f\"\\n[Scenario 2: Second-Price Auction]\")\nprint(f\"Bids (Truthful): {bids_second_price}\")\nprint(f\"Winner: {winner_2}\")\nprint(f\"Payment: ${pay_2:.2f} (This is the 2nd highest bid!)\")\nprint(f\"Winner's Profit (Utility): ${util_2:.2f}\")\n\n# --- VISUALIZATION ---\nplt.figure(figsize=(10, 5))\n\n# Plotting the Truthful/Second Price Scenario\nbars = plt.bar(names, bids_second_price, color='skyblue', label='Bid (True Value)')\n\n# Highlight the winner and the payment line\nplt.bar(winner_2, bids_second_price[names.index(winner_2)], color='green', label='Winner')\nplt.axhline(y=pay_2, color='red', linestyle='--', linewidth=2, label=f'Price Paid (${pay_2})')\n\nplt.title(\"Second-Price Auction: Winner pays the dashed line price\")\nplt.ylabel(\"Value / Bid ($)\")\nplt.legend()\nplt.show()\n\n\n\n\n\n","type":"content","url":"/chapter2#attempt-2-the-vickrey-auction-second-price","position":7},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish","lvl3":"What did we learn?","lvl2":"Attempt 2: The Vickrey Auction (Second-Price)"},"type":"lvl3","url":"/chapter2#what-did-we-learn","position":8},{"hierarchy":{"lvl1":"Chapter 2: Mechanism Design - The Art of Letting People Be Selfish","lvl3":"What did we learn?","lvl2":"Attempt 2: The Vickrey Auction (Second-Price)"},"content":"Look at the output of Scenario 2 (Second-Price Auction).\n\nAlice had the highest value ($100) and she won. This is Socially Optimal.\n\nAlice bid $100, but she only paid $90 (Dave’s bid).\n\nAlice made a profit of $10.\n\nWhy is telling the truth a Dominant Strategy?\nSuppose Alice tries to lie in a Second-Price Auction:\n\nCase A (Underbid): She bids $85 instead of $100.\n\nShe still wins (since $85 > $90 is false, wait... she would LOSE!).\n\nIf she bids $85, Dave (bidding $90) would win. Alice gets $0 utility. Lying hurt her.\n\nCase B (Overbid): She bids $150.\n\nShe still wins. She still pays the second highest price ($90).\n\nHer utility is exactly the same. Lying didn’t help.\n\nThis leads us to the most important theorem in Mechanism Design:\n\nVickrey’s Theorem: In a second-price sealed-bid auction, truthful bidding is a dominant strategy. It guarantees the item goes to the person who values it most, and it is computationally easy to run.","type":"content","url":"/chapter2#what-did-we-learn","position":9},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula"},"type":"lvl1","url":"/chapter3","position":0},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula"},"content":"In the previous chapter, we saw that charging the “Second-Highest Price” made people tell the truth. But that only works for simple, single-item auctions.\n\nWhat happens if the game is more complex?\n\nSponsored Search: There are 5 ad slots, some better than others.\n\nCloud Computing: You want to buy CPU time, and getting 10 hours is better than 5.\n\nHow do we set the price then to stop people from lying?","type":"content","url":"/chapter3","position":1},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula","lvl2":"The Problem"},"type":"lvl2","url":"/chapter3#the-problem","position":2},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula","lvl2":"The Problem"},"content":"We want to design a game where:\n\nAllocation Rule (x): Who gets what? (We usually give the most stuff to the highest bidders).\n\nPayment Rule (p): How much do they pay?\n\nIf we mess up the payment rule, people will lie.","type":"content","url":"/chapter3#the-problem","position":3},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula","lvl2":"The Solution: Myerson’s Lemma"},"type":"lvl2","url":"/chapter3#the-solution-myersons-lemma","position":4},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula","lvl2":"The Solution: Myerson’s Lemma"},"content":"Roger Myerson (a Nobel laureate) discovered a powerful rule. He proved that for any single-parameter environment (where you have one value for “getting the stuff”), you don’t have to guess the payment rule. The math decides it for you.\n\nMyerson’s Lemma states:\n\nMonotonicity: The allocation rule must be “sensible.” If you bid more, you must get more (or the same) amount of stuff. You can never get less by paying more.\n\nUnique Payments: Once you choose an allocation rule, there is only one mathematical formula for the payments that ensures truthfulness.","type":"content","url":"/chapter3#the-solution-myersons-lemma","position":5},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula","lvl3":"The Magic Formula","lvl2":"The Solution: Myerson’s Lemma"},"type":"lvl3","url":"/chapter3#the-magic-formula","position":6},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula","lvl3":"The Magic Formula","lvl2":"The Solution: Myerson’s Lemma"},"content":"The payment isn’t just a random number. It is related to the area under the curve of your allocation function.\\text{Payment} = \\text{Bid} \\times \\text{Allocation} - \\text{(Area under the Allocation Curve)}\n\nLet’s visualize this, because it turns a complex calculus concept into a simple geometry problem.\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef plot_myerson_payment(bid, allocation_func, rule_name):\n    \"\"\"\n    Visualizes Myerson's Payment formula as areas on a graph.\n    \"\"\"\n    \n    # Generate a range of possible bids (0 to 1.5x the actual bid)\n    b_values = np.linspace(0, bid * 1.5, 500)\n    x_values = [allocation_func(b) for b in b_values]\n    \n    # Calculate the specific values for the User's Bid\n    my_allocation = allocation_func(bid)\n    \n    # --- PLOTTING ---\n    plt.figure(figsize=(10, 6))\n    \n    # 1. Plot the Allocation Curve x(b)\n    plt.plot(b_values, x_values, color='black', linewidth=3, label='Allocation Rule x(b)')\n    \n    # 2. Shade the \"Surplus\" (Profit) Area (The area UNDER the curve)\n    # Myerson says: Your Utility = Area UNDER the curve up to your bid\n    plt.fill_between(b_values, x_values, where=(b_values <= bid), \n                     color='green', alpha=0.3, label='Your Utility (Profit)')\n    \n    # 3. Shade the \"Payment\" Area (The rectangle MINUS the curve)\n    # Total Value = Bid * Allocation (The full rectangle)\n    # Payment = Total Rectangle - Utility Area\n    plt.fill_between(b_values, x_values, my_allocation, where=(b_values <= bid), \n                     color='red', alpha=0.3, label='Your Payment')\n    \n    # Draw the specific bid line\n    plt.vlines(bid, 0, my_allocation, color='blue', linestyle='--', label=f'Your Bid: ${bid}')\n    plt.hlines(my_allocation, 0, bid, color='blue', linestyle=':')\n    \n    plt.title(f\"Myerson's Lemma: {rule_name}\", fontsize=14)\n    plt.xlabel(\"Bid Amount ($)\")\n    plt.ylabel(\"Allocation (Probability or Quantity)\")\n    plt.legend(loc='upper left')\n    plt.grid(True, alpha=0.3)\n    plt.show()\n\n# --- DEFINE DIFFERENT RULES ---\n\n# Rule 1: Single Item (Step Function)\n# If you bid > 50, you get the item (1). If not, you get nothing (0).\n# This mimics a Second-Price auction where the 2nd highest bid was 50.\ndef single_item_allocation(b):\n    return 1.0 if b >= 50 else 0.0\n\n# Rule 2: Fractional / Probability (Smooth Curve)\n# The more you bid, the higher probability you have of winning, or the more resources you get.\n# Example: x(b) = sqrt(b) / 10 (capped at 1.0)\ndef smooth_allocation(b):\n    val = np.sqrt(b) / 10\n    return min(val, 1.0)\n\n# --- RUN VISUALIZATION ---\n\n# Scenario A: You bid $80 in a Single Item auction (Threshold was $50)\nplot_myerson_payment(80, single_item_allocation, \"Single Item Auction (Step Function)\")\n\n# Scenario B: You bid $80 in a Resource Allocation auction (Smooth Curve)\nplot_myerson_payment(80, smooth_allocation, \"Cloud Resource Allocation (Smooth Function)\")\n\n\n\n\n\n","type":"content","url":"/chapter3#the-magic-formula","position":7},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula","lvl3":"Analysis of the Graphs","lvl2":"The Solution: Myerson’s Lemma"},"type":"lvl3","url":"/chapter3#analysis-of-the-graphs","position":8},{"hierarchy":{"lvl1":"Chapter 3: Myerson’s Lemma - The Universal Pricing Formula","lvl3":"Analysis of the Graphs","lvl2":"The Solution: Myerson’s Lemma"},"content":"Graph 1: Single Item (The Step Function)\n\nLook at the “Red Area” (Payment).\n\nThe allocation jumps from 0 to 1 exactly at $50 (this represents the competing bid).\n\nEven though you bid $80, the math shows you only pay the area defined by that jump: $50.\n\nThis proves that the “Second-Price” rule is just a specific version of Myerson’s Lemma!\n\nGraph 2: Smooth Allocation\n\nHere, bidding higher gets you gradually more stuff.\n\nNotice the Green Area (Profit) and Red Area (Payment).\n\nThe Intuition: You don’t pay your full bid. You get a “discount” equal to the green area.\n\nThe green area represents the “extra value” you bring to the system.\n\nConclusion:\nMechanism Design is powerful because it turns “incentives” into “geometry.” If we want people to tell the truth, we simply calculate their payment as the red area on the graph. We don’t need to trust them; the formula keeps them honest.","type":"content","url":"/chapter3#analysis-of-the-graphs","position":9}]}